> 해당 글은 [혼자 공부하는 컴퓨터 구조+운영체제](https://www.yes24.com/Product/Goods/128858060)을 정리한 내용입니다.

# 목차
1. [네트워크 알아보기](#01-네트워크-알아보기)
    1. [네트워크 그리고 인터넷과 웹](#01-1-네트워크-그리고-인터넷과-웹)
        1. [네트워크와 인터넷](#네트워크와-인터넷)
        2. [웹과 웹 서비스](#웹과-웹-서비스)
    2. [네트워크의 종류](#01-2-네트워크의-종류)
        1. [근거리 통신망 LAN](#근거리-통신망-lan)
        2. [광역 통신망 WAN](#광역-통신망-wan)
    3. [네트워크에서 데이터를 주고받는 방법](#01-3-네트워크에서-데이터를-주고받는-방법)
    4. [프로토콜이란 무엇일까?](#01-4-프로토콜이란-무엇일까)
2. [네트워크 모델 알아보기](#02-네트워크-모델-알아보기)
    1. [TCP/IP와 OSI 7계층](#02-1-tcpip와-osi-7계층)
        1. [TCP/IP 모델](#tcpip-모델)
        2. [OSI 7계층 모델](#osi-7계층-모델)
        3. [TCP/IP 모델과 OSI 7계층 모델 비교](#tcpip-모델과-osi-7계층-모델-비교)
    2. [네트워크 패킷](#02-2-네트워크-패킷)
        1. [캡슐화 - 패킷을 만들어서 보낼 때](#캡슐화---패킷을-만들어서-보낼-때)
        2. [역캡슐화 - 패킷을 받아서 확인할 때](#역캡슐화---패킷을-받아서-확인할-때)
    3. [패킷을 이용한 통신 과정](#02-3-패킷을-이용한-통신-과정)
3. [근거리 통신 방법(OSI 2계층)](#03-근거리-통신-방법osi-2계층)
    1. [데이터 링크 계층 살펴보기](#03-1-데이터-링크-계층-살펴보기)
        1. [데이터의 흐름을 관리하는 스위칭](#데이터의-흐름을-관리하는-스위칭)
        2. [오류 점검](#오류-점검)
    2. [MAC 주소](#03-2-mac-주소)
    3. [Ethernet 프로토콜](#03-3-ethernet-프로토콜)
4. [IP 주소를 활용한 통신 방법(OSI 3계층)](#04-ip-주소를-활용한-통신-방법osi-3계층)
    1. [네트워크 계층 살펴보기](#04-1-네트워크-계층-살펴보기)
        1. [라우팅](#라우팅)
    2. [IP 주소](#04-2-ip-주소)
        1. [클래스풀 IP](#클래스풀-ip)
        2. [클래스리스 IP](#클래스리스-ip)
        3. [공인 IP와 사설 IP](#공인-ip와-사설-ip)
5. [ARP 프로토콜 알아보기](#05-arp-프로토콜-알아보기)
    1. [ARP 프로토콜이란 무엇일까?](#05-1-arp-프로토콜이란-무엇일까)
        1. [ARP 프로토콜의 구조](#arp-프로토콜의-구조)
        2. [ARP 요청과 응답 프로토콜](#arp-요청과-응답-프로토콜)
        3. [ARP 프로토콜의 전송](#arp-프로토콜의-전송)
    2. [ARP 캐시 테이블](#05-2-arp-캐시-테이블)
    3. [ARP 프로토콜의 통신 과정](#05-3-arp-프로토콜의-통신-과정)
6. [광역 통신 방법](#06-광역-통신-방법)
    1. [IPv4 프로토콜](#06-1-ipv4-프로토콜)
        1. [IPv4 프로토콜의 구조](#ipv4-프로토콜의-구조)
        2. [IPv4 프로토콜의 TTL(생존 시간)](#ipv4-프로토콜의-ttl생존-시간)
    2. [ICMP 프로토콜](#06-2-icmp-프로토콜)
        1. [ICMP의 구조](#icmp의-구조)
    3. [라우팅 테이블](#06-3-라우팅-테이블)
    4. [멀리 떨어진 컴퓨터와 통신하는 과정](#06-4-멀리-떨어진-컴퓨터와-통신하는-과정)
    5. [IPv4 패킷 조각화](#06-5-ipv4-패킷-조각화)

# 01 네트워크 알아보기

## 01-1 네트워크 그리고 인터넷과 웹

### 네트워크와 인터넷
* 네트워크
    * 여러 컴퓨터를 연결한 통신망
        * ex. 컴퓨터와 공유기, 스마트폰과 TV

* 인터넷
    * 세상에 존재하는 무수히 많은 통신망 가운데 규모가 가장 큰 네트워크
        * 전 세계에 있는 컴퓨터를 모두 연결할 만큼 큰 네트워크

### 웹과 웹 서비스
* 웹
    * 웹 서비스

* 웹 서비스
    * 웹 브라우저라는 클라이언트 프로그램으로 웹 서버 프로그램에 저장된 다양한 데이터를 인터넷 같은 네트워크 통신망을 이용해서 내려받는 서비스
        * ex. HTML, CSS, 자바스크립트와 같은 웹 페이지 파일, 그림, 영샹, 음성 파일 등

## 01-2 네트워크의 종류

* LAN(local area network)
    * 여러 시스템이 하나의 네트워크 장비(스위치)에 연결된 네트워크

* WAN(wide area network)
    * LAN이 하나 이상으로 구성된 네트워크

* CAN(campus area network)
    * 대학 캠퍼스처럼 여러 건물을 연결하는 네트워크

* MAN(metropolice area network)
    * 한 도시 전체를 연결한 네트워크

### 근거리 통신망 LAN
* LAN
    * 집이나 학교, 강의실, 사무실 등 특정 장소에서 가까운 곳에 있는 컴퓨터끼리 연결한 네트워크
    * 같은 공간이나 멀지 않은 곳에서 서로 연결된 컴퓨터와 장비는 '하나의 네트워크에 연결됐다' 또는 '같은 LAN 대역이다'라고 표현

* 랜선
    * 컴퓨터와 네트워크 장비(공유기)를 연결하는 선
    * 컴퓨터를 LAN에 연결하는 선

### 광역 통신망 WAN
* WAN
    * 국가, 대륙 등과 같이 멀리 떨어져 있는 넓은 지역을 연결하는 네트워크
        * '멀다'의 기준
            * 가까운 곳을 연결한 LAN과 또 다른 LAN을 하나로 합친 것
    * WAN을 구성하는 LAN의 수는 정해져 있지 않음
        * ex. 인터넷은 전 세계에서 가장 큰 WAN

## 01-3 네트워크에서 데이터를 주고받는 방법
* 유니캐스트(unicast)
    * 데이터를 특정 컴퓨터 1대에만 보내는 방식
    * 네트워크 통신에서 가장 일반적

* 멀티캐스트(multicast)
    * 데이터를 같은 네트워크에 있는 특정 컴퓨터 여러 대에 보내는 방식
    * 특수한 경우에만 사용

* 브로드캐스트(broadcast)
    * 데이터를 같은 네트워크에 있는 모든 컴퓨터에 보내는 방식
    * 특정 대상을 지정할 수 없을 때 사용

## 01-4 프로토콜이란 무엇일까?
* 프로토콜
    * 네트워크에서 데이터를 주고받을 때 사용하는 양식
    * 용도에 따라서 알맞은 프로토콜을 사용해 데이터를 보냄
        * Ethernet(이더넷): 가까운 곳의 컴퓨터와 데이터를 주고받을 때
        * IP(internet protocol): 멀리 있는 컴퓨터와 데이터를 주고받을 때
        * TCP(transmission control protocol) 또는 UDP(user datagram protocol): 특정 컴퓨터에서 실행 중인 프로그램에 데이터를 전달하고 싶을 때

# 02 네트워크 모델 알아보기

## 02-1 TCP/IP와 OSI 7계층

* 네트워크 모델
    * 인터넷의 수많은 네트워크를 통일된 형태로 연결하는 방법

### TCP/IP 모델
* TCP/IP 모델
    * 인터넷에 연결된 컴퓨터들이 데이터를 주고받을 수 있도록 하는 인터넷 표준 프로토콜을 위해 만들어짐
    * 4계층으로 구성
    * 각 계층 간에 상호 작동하는 방식을 정해 놓은 네트워크 모델

### OSI 7계층 모델
* OSI 7계층 모델
    * 네트워크가 발전하고 기능이 다양해지면서 각 계층을 좀 더 세분화한 표준
    * 7계층으로 구성

### TCP/IP 모델과 OSI 7계층 모델 비교
* 공통점
    * 네트워크 통신을 역할별로 계층화해서 구성

* 차이점
    * TCP/IP 모델
        * 초기 인터넷의 개발과 함께 나왔음
        * 실제 인터넷에서 통신하는 방식을 그대로 표현
    * OSI 7계층 모델
        * 국제 표준화를 목적으로 만든 이론적인 모델
        * 실제 통신하는 방식과는 조금 다름

* 결론
    * 네트워크 통신 방식을 실습으로 자세하게 확인할 때는 TCP/IP 모델을 기준으로 학습
    * 복잡하고 다양한 기능을 설명하고 확인할 때는 OSI 7계층 모델을 기준으로 학습

TCP/IP 모델 | 대표 장비 | 주소 | 프로토콜 | OSI 7계층 모델
---|---|---|---|---
4 응용 | - | - | HTTP, FTP, DNS 등 | 7 응용
4 응용 | - | - | JPEG, PNG, ZIP, MP4 등 | 6 표현
4 응용 | - | - | NetBIOS, SMB, PPTP, RPC 등 | 5 세션
3 전송 | 로드밸런서 | 포트 번호 | TCP, UDP 등 | 4 전송
2 인터넷 | 라우터 | IP 주소 | ARP, IP, ICMP 등 | 3 네트워크
1 네트워크 엑세스 | 스위치 | MAC 주소 | Ethernet, ppp 등 | 2 데이터 링크
1 네트워크 엑세스 | 랜선, 랜카드 | - | IEEE 802.3, IEEE 802.11 | 1 물리

* OSI 7계층 모델
    1. 물리 계층(physical layer)
        * 컴퓨터의 랜카드와 랜선 같은 하드웨어 장치를 통해 전기 신호인 비트를 전송하는 데 필요한 물리적인 명세를 정하고 전송하는 역할

    2. 데이터 링크 계층(data link layer)
        * 출발지 컴퓨터에서 목적지 컴퓨터까지 같은 LAN에 있는 장치들을 찾아가는 역할

    3. 네트워크 계층(network layer)
        * 출발지 컴퓨터에서 목적지 컴퓨터를 찾아갈 수 있도록 라우팅 역할
            * 라우팅: 경로를 찾아가는 과정
        * 인터넷에서 목적지 컴퓨터를 찾아갈 때는 수많은 경로가 있는데, 그때마다 최적의 경로라고 생각하는 쪽을 선택
        * IPv4
            * 최적의 경로를 찾아가는 역할을 수행하는 프로토콜
        * 나머지 프로토콜
            * IPv4를 보조하는 역할

    4. 전송 계층(transport layer)
        * 출발지와 목적지 컴퓨터에서 각각 실행 중인 프로그램이 서로를 찾을 수 있도록 하고, 각 프로그램이 데이터를 주고받으면서 누락된 데이터를 다시 전송하게 하거나 아니면 한 번에 전송할 데이터의 크기를 정하는 등의 역할

    5. 세션 계층(session layer)
        * 컴퓨터나 네트워크 장치 사이의 세션을 설정, 관리, 종료하는 역할
            * 세션: 네트워크가 연결된 상태

    6. 표현 계층(presentation layer)
        * 입력 또는 출력되는 데이터를 하나의 표현 형태로 변환

    7. 응용 계층(application layer)
        * 사용자가 이용하는 프로그램의 양식에 따라 데이터를 주고받는 계층
        * 프로그램은 각각 해당 프로그램끼리 통신할 수 있는 양식이 정해져 있는데, 이를 정의한 계층

* 대표적인 프로토콜
    * HTTP
        * 웹 서버와 웹 클라이언트 프로그램이 서로 통신하기 위해 사용
        * 주로 어떤 파일을 달라고 요청하거나 해당 파일을 보낼 때 사용
    * TCP
        * 컴퓨터에 실행 중인 여러 프로그램 가운데 통신 대상을 찾을 때 사용
    * IPv4
        * 인터넷에 연결된 수많은 컴퓨터 가운데 특정 컴퓨터를 찾아갈 때 사용
    * Ethernet
        * IPv4를 이용해 멀리 있는 특정 컴퓨터를 찾아갈 때 여러 LAN을 거치는데, 이때 같은 LAN에 있는 다른 컴퓨터를 찾아갈 때 사용

## 02-2 네트워크 패킷

* 패킷
    * 데이터와 프로토콜의 집합
        * 데이터를 전달할 때는 필요한 내용을 각각 용도에 맞는 프로토콜과 조합해야 함
    * 데이터를 보내는 쪽에서 만듬

* 패킷의 구조
    * 헤더
        * 각 용도에 맞는 프로토콜
        * 프로토콜이 여러 개 구성될 수 있음
            * 한 프로토콜 앞에 또 다른 프로토콜이 헤더로 추가될 수 있음
                * 헤더 앞에 추가로 붙는 헤더는 기존 헤더보다 더 낮은 계층의 프로토콜
    * 페이로드
        * 보낼 데이터
    * 푸터
        * 오류를 점검하기 위한 값
            * 이 값은 헤더와 페이로드를 복잡한 수식에 입력하여 계산

### 캡슐화 - 패킷을 만들어서 보낼 때
* 캡슐화
    * 패킷을 만들 때는 필요에 따라 프로토콜을 여러 개 추가할 수 있는데, 이때 네트워크 모델의 높은 계층에서부터 낮은 계층의 프로토콜을 순서대로 추가하면서 만듬

### 역캡슐화 - 패킷을 받아서 확인할 때
* 역캡슐화
    * 패킷을 전달받은 컴퓨터에서는 반대로 낮은 계층의 프로토콜에서 높은 계층의 프로토콜 순서로 분해하면서 내용을 확인하는 것

## 02-3 패킷을 이용한 통신 과정
* 생략

# 03 근거리 통신 방법(OSI 2계층)

## 03-1 데이터 링크 계층 살펴보기
* 데이터 링크
    * 같은 LAN에서 특정 컴퓨터를 찾아가서 통신할 수 있게 해줌

* 데이터 링크 기능
    1. 데이터의 흐름을 관리하는 스위칭
    2. 데이터의 오류를 점검하는 기능

### 데이터의 흐름을 관리하는 스위칭
* 스위칭
    * 네트워크 장치(공유기 또는 스위치)는 포트에 랜선으로 컴퓨터를 연결했을 때 해당 컴퓨터의 고유한 주소를 저장
        * 이 주소를 통해 데이터를 전송할 컴퓨터가 연결된 포트를 구분
    * MAC 주소
        * 데이터 링크 계층에서 사용하는 주소

### 오류 점검
* 오류 점검
    * 네트워크 패킷의 푸터에는 일반적으로 CRC라는 방식으로 계산한 값을 추가
    * 데이터를 보낼 때 CRC는 헤더와 페이로드로 계산한 점검값을 푸터에 추가하고, 데이터를 받는 쪽에서는 보낼 때와 똑같은 방식으로 계산해서 받은 푸터값과 비교
        * 정상: 두 값이 같을 때
        * 오류: 두 값이 다를 때

## 03-2 MAC 주소
* MAC 주소
    * 같은 LAN에서 특정 네트워크 장치를 찾아가기 위해 특정 장치를 고유하게 식별할 수 있게 해줌
    * 인터넷으로 통신하는 모든 장치에는 랜카드(네트워크 인터페이스 카드)가 연결되어 있고, 이 랜카드에 MAC 주소가 할당되어 있음
    * 12자리의 16진수 숫자로 구성
        * ex. '00:1A:2B:3C:4D:5E' 또는 '00-1A-2B-3C-4D-5E'

## 03-3 Ethernet 프로토콜
* Ethernet 프로토콜
    * 특정 장치에 데이터를 보낼 때 MAC 주소를 작성하는 양식
    * 총 14bytes로 구성
        1. 목적지 MAC 주소 6bytes
        2. 출발지 MAC 주소 6bytes
        3. 상위 프로토콜의 유형 2bytes
            * 데이터를 캡슐화할 때 사용한 3계층 프로토콜이 무엇인지 알려주는 역할
                1. ARP: 0x0806이라고 표시
                2. IPv4: 0x0800이라고 표시

* 프리엠블(preamble)
    * 전송의 동기화 및 시작을 알리기 위해 프레임(데이터 운반체) 단위별로 각 프레임의 맨 앞에 붙이는 영역
    * Ethernet 프로토콜이 시작되는 지점을 알려 주는 기능
    * 8bytes의 크기
        * 7bytes
            * 1010 1010이 일곱 번 반복하면서 전기 신호를 보내는 쪽의 속도와 받는 쪽의 속도를 동기화
        * 1byte
            * 1010 1011을 전송해 그다음부터 Ethernet 프로토콜의 시작을 알려 줌
            * 시작을 알려주는 SFD(start of frame delimiter)

# 04 IP 주소를 활용한 통신 방법(OSI 3계층)

## 04-1 네트워크 계층 살펴보기
* 네트워크
    * 여러 LAN이 연결된 인터넷 같은 네트워크를 통해 데이터를 보낼 때에 필요한 역할을 수행

### 라우팅
* 라우팅
    * 멀리 떨어진 곳을 찾아갈 때 더 나은 경로를 이용할 수 있게 해주는 기능
    * 일반적으로 인터넷은 라우터라는 3계층 장비를 통해서 전 세계가 연결되는데, 라우터는 KT, SKT, LGT와 같은 통신사들이 설치하고 네트워크 대역을 찾아갈 수 있도록 설정
        * 이 설정에 따라 내 컴퓨터가 다른 컴퓨터와 통신하는 경로가 결정
        * 특정 통신사가 전 세계를 연결하는 인터넷의 모든 네트워크 대역을 관리할 수는 없으므로 라우터에는 일반적으로 기본 경로를 설정

## 04-2 IP 주소
* IP
    * 내 컴퓨터에서 다른 특정 LAN에 있는 컴퓨터를 찾아갈 때 사용하는 주소
    * 멀리 있는 컴퓨터와 통신할 때는 IP 주소로 LAN을 찾고, 해당 LAN에 있는 컴퓨터와 통신할 때는 2계층의 MAC 주소를 사용
    * 10진수를 점(.)으로 구분해 총 4개의 필드로 나누어 작성
        * 각 필드는 0~255까지 숫자만 사용할 수 있음
            * ex. IP 주소의 필드는 각각 1byte이므로 0000 0000 ~ 1111 1111까지만 입력할 수 있고, 최댓값인 1111 1111을 10진수로 바꾸면 255

### 클래스풀 IP
* 클래스풀 IP
    * 클래스 기반의 IP 주소 체계

* D, E 클래스
    * 특수한 목적을 위해 사용하지 않음

### 클래스리스 IP
* 클래스리스 IP
    * 필드에 꼭 맞게 구분하는 것이 아니라 좀 더 세분화해 적당한 부분에서 구분하기로 한 것

### 공인 IP와 사설 IP
* 공인 IP
    * 외부 LAN과 통신할 때 같은 LAN에서 공유해 사용하는 IP
    * 공유기에 설정

* 사설 IP
    * 같은 LAN에서만 사용하는 IP
    * 각 컴퓨터에 설정

## 04-3 특수한 IP 주소

### 네트워크 ID 주소
* 네트워크 ID 주소
    * 컴퓨터에 설정할 수 없는 주소로 네트워크 대역 자체를 나타냄
    * 컴퓨터에는 설정할 수 없음

### 브로드캐스트 주소
* 브로드캐스트 주소
    * 네트워크 대역에 연결된 모든 컴퓨터와 통신하는 주소
    * 컴퓨터에는 설정할 수 없음

### 게이트웨이 주소
* IP 주소와 라우팅으로 패킷이 어디로 가야 하는지 결정할 때 경로가 따로 설정되어 있지 않으면 무조건 등록된 주소로 가도록 설정
* 공유기에서 사용, 컴퓨터에도 설정할 수 있음
    * 하지만 같은 네트워크 대역에서 공유기와 컴퓨터가 같은 IP 주소를 사용하면 둘 중 하나는 통신을 할 수 없음

### 로컬호스트 주소
* 로컬호스트 주소
    * 루프백 주소
    * 127.0.0.1 주소를 가리킴
    * 내 컴퓨터 자체를 뜻함
    * 내 컴퓨터의 특정 네트워크 서비스나 내 컴퓨터에서 통신이 잘 되는지 확인하는 데 사용

# 05 ARP 프로토콜 알아보기

## 05-1 ARP 프로토콜이란 무엇일까?

* ARP(address resolution protocol)
    * IP 주소로 MAC 주소를 알아내는 주소 결정 프로토콜
        1. 다른 사람과 통신하기 위해 상대의 IP 주소를 입력
        2. 컴퓨터는 통신할 장치에 ARP 요청 프로토콜을 이용해 MAC 주소를 알려 달라고 요청
        3. 해당 요청을 받은 컴퓨터는 다시 ARP 응답 프로토콜로 자신의 MAC 주소를 응답해 줌
        * 이렇게 통신할 장치의 MAC 주소를 알아야 비로소 통신할 수 있음
            * 즉, IP 주소로 통신하기 전에 먼저 ARP 프로토콜로 MAC 주소를 알아내는 과정이 수행

### ARP 프로토콜의 구조
1. 하드웨어 유형
    * 현재 사용하는 2계층 주소의 유형
        * 일반적으로 2계층에서는 MAC 주소만 사용하므로 Ethernet을 의미하는 값 0x0001이 작성됨
2. 프로토콜 유형
    * 3계층 주소의 유형
        * 3계층에서는 일반적으로 IPv4 주소를 사용하므로 이를 의미하는 값 0x0800이 작성됨
3. 하드웨어 주소 길이
    * MAC 주소의 길이가 6bytes이므로 0x06이 작성됨
4. 프로토콜 주소 길이
    * IPv4 주소의 길이가 4bytes이므로 0x04이 작성됨
5. 오퍼레이션 코드
    * MAC 주소를 요청하는 패킷인지, 아니면 요청에 응답하는 패킷인지 구분하는 데 사용됨
        * 값이 0x0001이면 요청하는 패킷, 0x0002이면 응답하는 패킷
6. 출발지의 MAC과 IP 주소
7. 목적지의 MAC과 IP 주소

### ARP 요청과 응답 프로토콜
* ARP 프로토콜은 IP 주소로 통신할 장치의 MAC 주소를 알아내는 프로토콜이라고 했는데, 알 수 없는 목적지의 MAC 주소가 어떻게 작성되고 해당 주소로 어떻게 전달할 수 있을까?
    * MAC 주소를 요청할 때와 응답받을 때 ARP 프로토콜이 작성되는 방법과 통신하는 방법이 다름
        * 같은 점
            * 하드웨어와 프로토콜의 유형 그리고 주소 길이는 거의 고정된 값으로 작성됨
        * 다른 점
            * 현재 ARP 프로토콜이 요청하는 것인지 응답하는 것인지를 나타내는 오퍼레이션 코드와 목적지 MAC 주소의 유무
                1. MAC 주소를 요청: 목적지의 MAC 주소를 모르기 때문에 0으로 채움
                2. MAC 주소를 응답: 요청하는 쪽에서 보내 준 ARP 프로토콜에서 출발지 MAC 주소를 보면 내가 응답해야 할 목적지 MAC 주소를 알 수 있음

### ARP 프로토콜의 전송
* ARP 요청 프로토콜을 보낼 때
    * 상대방의 MAC 주소를 알지 못하므로 Ethernet 프로토콜의 목적지 MAC 주소를 ff:ff:ff:ff:ff:ff로 작성하여 캡슐화하고 브로드캐스트로 같은 네트워크에 있는 모든 장치에 ARP 요청 프로토콜을 보냄

## 05-2 ARP 캐시 테이블
* ARP 캐시 테이블
    * 한 번 알아낸 MAC 주소는 목적지의 IP와 MAC 주소를 ARP 캐시 테이블에 기록
        * 일정 시간 동안은 다시 MAC 주소를 알아내는 과정 없이 ARP 캐시 테이블에 있는 MAC 주소로 통신

## 05-3 ARP 프로토콜의 통신 과정
* 생략

# 06 광역 통신 방법

## 06-1 IPv4 프로토콜

* IPv4 프로토콜
    * IPv4 주소를 작성하는 양식
    * 기능
        1. 최적의 경로를 찾아가는 역할을 수행하는 프로토콜
        2. 큰 데이터를 잘라서 보내는 기능
        3. 경로가 잘못 설정되었을 때를 대비할 수 있는 기능
        4. IPv4 프로토콜 자체에 문제가 없는지 확인하는 기능

### IPv4 프로토콜의 구조
* IP 옵션
    * 필요할 때 추가할 수 있는 정보, 일반적으로 많이 사용되지 않음
    * 정보가 추가될 때마다 4bytes의 내용이 추가됨
* 버전
    * IP 프로토콜의 버전을 나타냄
    * 4라고 작성
    * 필드가 4bits이므로 16진수 값 하나를 작성
* 인터넷 헤더 길이
    * IPv4 프로토콜의 길이를 의미
    * 5라고 작성
    * 필드가 4bits이므로 16진수 값 하나를 작성
* 서비스 유형
    * 차등화 서비스 필드
    * 패킷의 QoS를 향상시키고 트래픽을 효율적으로 관리할 목적으로 사용
        * ex. 패킷이 실시간 오디오나 비디오 스트리밍처럼 시간에 민감한 애플리케이션에 의해 생성된 경우, 해당 패킷에 대한 우선순위를 높일 수 있다. 하지만 특정 네트워크 장치에서만 사용하고 일반적으로 컴퓨터에서는 사용하지 않는다. 그래서 컴퓨터로 IPv4 패킷을 캡처해 보면 0x00으로 비어있다.
* 총 길이
    * 데이터와 상위 프로토콜, IPv4 프로토콜까지 모두 합한 크기를 의미
* 아이디
    * 여러 개로 나눠서 보내는 데이터들이 원래는 하나의 데이터라는 것을 구분하기 위해 각 데이터 앞에 캡슐화하는 IPv4 프로토콜이 모두 같은 아이디를 가지도록 설정하는 값
* IP 플래그
    * 3bits로 되어 있음
        * 첫 번째 비트의 값: 사용하지 않으므로 항상 0
        * 두 번째 비트의 값: 1로 설정하면 큰 데이터를 통째로 보냄
        * 세 번째 비트의 값: 1로 설정하면 큰 데이터를 조금씩 잘라서 보냄
* 조각 오프셋
    * 큰 데이터를 잘라서 보낼 때 여러 개로 나뉜 데이터의 순서를 나타냄
        * 데이터를 받는 쪽에서는 이 값을 참고해 다시 원래대로 조립함
        * 정확히 순서 번호를 의미하기보다는 맨 처음 데이터에서 얼만큼 떨어진 곳에 있는 데이터인지를 의미
            * 해당 값을 8로 나눈 값을 작성
* 생존 기간(TTL)
    * 패킷이 네트워크에서 살아남을 수 있는 시간을 의미
        * 패킷이 한 네트워크에서 다른 네트워크로 넘어갈 때 TTL을 1씩 감소하면서 0으로 되는 순간 패킷을 폐기
            * 패킷이 네트워크에서 영원히 떠돌아다니는 것을 방지하기 위한 것
* 프로토콜
    * IPv4 프로토콜 다음에 역캡슐화해야 하는 프로토콜이 무엇인지 작성해 두는 곳
        * IPv4 프로토콜 다음에는 같은 3계층인 ICMP, 4계층인 TCP, UDP가 올 수 있음
            * ICMP: 1로 설정
            * TCP, UDP: 각각 6과 17로 설정
* 헤더 체크섬
    * 패킷을 전달받은 곳에서 IPv4 프로토콜이 문제가 없는지 확인하는 부분
* 출발지 IPv4, 목적지 IPv4 주소

### IPv4 프로토콜의 TTL(생존 시간)
* TTL
    * 라우터나 공유기 같은 네트워크 장치를 통해 하나의 LAN을 넘어갈 때마다 1씩 줄어드는 값으로, 0이 되면 더 이상 다음 LAN으로 전송하지 않고 패킷을 폐기할 수 있도록 설정하는 값

* TTL이 없다면 생길 수 있는 문제
    1. 패킷을 전송할 때 네트워크 장비가 잘못 설정되어 패킷이 계속 순환하는 상태가 된다면 해당 패킷은 영원히 전달되지 않음
    2. 패킷을 보낸 쪽은 받은 쪽으로부터 잘 받았다는 응답을 받지 못했으므로 다시 패킷을 전송하고 이런 패킷은 점점 쌓여 해당 패킷을 처리하는 네트워크 장치들의 CPU나 메모리 같은 자원을 소모하게 됨

## 06-2 ICMP 프로토콜

* ICMP
    * 3계층, IPv4를 이용해 멀리 떨어진 컴퓨터끼리 통신이 잘 되는지 확인하고 안 된다면 원인을 파악할 수 있게 도와 주는 인터넷 제어 메세지 프로토콜

### ICMP의 구조
* 유형, 코드, 체크섬, 기타 메시지 관련 정보로 구성
* ICMP는 통신할 대상에 요청 프로토콜을 보내고 응답 프로토콜을 받아서 통신을 확인
    * 응답에 따라 통신이 정상으로 이뤄졌는지를 구분
        * 유형값: 큰 내용을 구분
        * 코드값: 좀 더 자세한 내용을 확인

## 06-3 라우팅 테이블

* 라우팅 테이블
    * IP 주소로 통신하는 컴퓨터나 네트워크 장치들이 모두 가지고 있는 것
    * 목적지의 IP 주소를 찾아갈 때에 어떤 경로로 가야 하는지 작성된 표

* 내 컴퓨터나 네트워크 장치에 직접 연결된 네트워크 장치
    * 통신 경로가 라우팅 테이블에 자동으로 설정
        * 특별한 설정을 하지 않아도 통신이 가능

* 내 컴퓨터와 직접 연결되지 않은 네트워크 장치와 통신하는 경로
    * 수동으로 추가해야 하지만, 전 세계에 있는 모든 네트워크 장치를 대상으로 통신 경로를 하나하나 수동으로 추가하는 것은 불가능에 가까움
        * 각 네트워크의 출입문 역할을 하는 게이트웨이 주소를 사용
        * 기본 게이트웨이
            * 라우팅 테이블에 존재하지 않는 경로일 때 어디로 가야 할지를 설정한 주소

## 06-4 멀리 떨어진 컴퓨터와 통신하는 과정
* 생략

## 06-5 IPv4 패킷 조각화
* IPv4 프로토콜은 큰 데이터를 작게 나눠서 보내는 패킷 조각화 기능이 있음
    * 최대 전송 단위
        * 네트워크 장비들마다 한 번에 전송할 수 있는 데이터의 최대 크기
        * 데이터의 크기가 MTU를 초과하면 작은 패킷으로 나눠서 전송
    * 일반적으로 네트워크 장치의 MTU는 1,500bytes로 설정
        * 따라서 1,500bytes 이상의 데이터는 조각화해서 보내야 함
        * 패킷을 조각화해야 할지 판단하는 것은 IPv4 프로토콜이 캡슐화되고 Ethernet 프로토콜이 캡슐화되기 전
            * 즉, 네트워크 장치가 IPv4 프로토콜을 캡슐화하고 나서 송수신할 데이터가 MTU 이상의 크기이면 조각화함
                * 따라서 큰 데이터를 주고받는 통신을 한다면 캡슐화할 프로토콜의 크기까지 고려해야 함

# 07 프로그램이 데이터를 주고받는 방법(OSI 4계층)

## 07-1 전송 계층 살펴보기

* 전송 계층
    * 데이터링크와 네트워크 계층을 거쳐서 찾아간 컴퓨터에 실행 중인 프로그램 가운데 특정 프로그램을 찾고, 해당 프로그램과 데이터를 주고받을 수 있게 해줌

### 클라이언트 - 서버 모델
* 클라이언트 - 서버 모델
    * 프로그램을 만들 때 요청을 보내는 클라이언트 프로그램과 이에 응답하는 서버 프로그램을 분리한 형태
    * 네트워크 통신을 이용하는 대부분의 프로그램은 클라이언트-서버 모델로 만듬
        * 어떤 프로그램은 서버 역할을 하면서 동시에 여러 가지 클라이언트 역할도 함께 수행하도록 만들기도 함
            * ex. 백엔드 개발자가 개발하는 서버 - 사용자들의 요청을 받는 서버의 역할과 동시에 데이터베이스 서버에 데이터를 전송하는 클라이언트 역할도 함

### 서버 프로그램
* 서버
    * 서비스를 제공하는 프로그램
        * 즉, 어떤 컴퓨터든지 서버 프로그램을 설치하고 실행하면 서버 컴퓨터가 됨

* 서버 프로그램
    * 특정 서비스를 제공하는 프로그램
        * ex. 파일 다운로드 서비스를 제공하면 파일 서버 프로그램, 네트워크 게임 서비스를 제공하면 게임 서버 프로그램, 카카오톡 메시지를 주고받는 서비스를 제공하면 카카오톡 메시지 서버 프로그램

### 클라이언트 프로그램
* 클라이언트 프로그램
    * 네트워크를 통해 특정 서버 프로그램이 제공하는 서비스를 이용할 수 있는 프로그램
        * ex. 게임, 웹 브라우저, 카카오톡 같은 메신저 등 사용자들이 이용하는 대부분의 프로그램

## 07-2 포트 번호

* 포트 번호
    * 컴퓨터에서 실행 중인 많은 프로그램 가운데 특정 프로그램을 찾아가기 위한 번호
    * 번호가 똑같아도 UDP와 TCP의 포트 번호가 서로 구별되며 1~65535번까지 사용할 수 있음
        * 즉, UDP 포트 번호 1~65535번, TCP 포트 번호 1~65535번까지 있음
        * 1~65535번 포트 번호는 동적 포트, 잘 알려진 포트, 예약된 포트 등 크게 세 가지 부류로 나눠 볼 수 있음

* 동적 포트
    * 일반적으로 클라이언트 프로그램이 사용하는 포트 번호
    * 운영체제에서 프로그램이 실행될 때 49152~65535번 중에서 남은 번호를 사용

* 잘 알려진 포트
    * 일반적으로 서버 프로그램이 사용하는 포트 번호
    * 아무 번호나 설정해도 되지만, 클라이언트들이 서비스를 편리하게 이용할 수 있도록 잘 알려진 포트 번호로 설정하는 것이 좋음

    서비스 이름 | 포트 번호
    ---|---
    FTP | 20, 21
    SSH | 22
    TELNET | 23
    DNS | 53
    DHCP | 67, 68
    TFTP | 69
    HTTP | 80
    HTTPS | 443

* 예약된 포트
    * 서버 프로그램이 주로 사용하는 포트 번호
    * 전 세계적으로 유명하거나 많이 사용하는 서버 프로그램이 아닌 조금은 덜 유명한 서버 프로그램이 사용하는 포트 번호
    * 꼭 해당 번호를 사용해야 하는 것은 아니지만, 서비스를 이용하는 클라이언트를 위해 정해진 포트 번호를 사용하는 것이 좋음

    서비스 이름 | 포트 번호
    ---|---
    오라클 DB 서버 | 1521
    MySQL 서버 | 3306
    MS 원격 데스크톱 | 3389

## 07-3 TCP와 UDP

* TCP, UDP
    * 특정 프로그램을 찾아가 프로그램끼리 데이터를 주고받을 수 있게 해주는 전송 계층 프로토콜
    * 프로그램을 어떻게 개발하느냐에 따라 한 프로그램이 TCP와 UDP를 모두 사용할 수도 있음
        * ex. 웹 서버 - 주로 TCP 사용, DNS 서버 프로그램 - 주로 UDP 사용
            * 이 두 프로그램도 한 가지 프로토콜만 사용하는 것은 아님

### TCP 알아보기
* TCP(transmission control protocol)
    * 신뢰할 수 있는 연결 지향 프로토콜
    * 클라이언트 프로그램과 서버 프로그램이 데이터를 주고받으면서 통신이 잘되고 있는지 확인하면서 서로의 통신을 동기화함
        1. 데이터를 주고받기 전에 제대로 연결되었는지 확인
        2. 데이터를 주고받는 중간에도 제대로 전달되었는지 확인
            * 만약 제대로 전달되지 않았다면 다시 보내 달라고 요청
        3. 데이터를 주고받는 과정이 끝나면 그냥 연결을 끊는 것이 아니라, 연결이 안전하게 종료될 수 있도록 확인하는 과정을 거침

### UDP 알아보기
* UDP(user datagram protocol)
    * 신뢰할 수 없는 비연결성 프로토콜
    * MAC과 IPv4 주소 그리고 포트 번호를 이용해 찾아간 프로그램과 데이터를 주고받지만, 완전성을 보증하지 않음
    * 데이터가 100% 완벽하게 전달되었는지를 확인할 필요가 없거나 한 번에 작은 양의 데이터를 전송하는 서비스에서 주로 사용
        * ex. 동영상 스트리밍 서비스

### TCP와 UDP 비교
* TCP 장점
    * 중간에 데이터가 누락되거나 문제가 생기면 데이터를 다시 주고받을 수 있음
* TCP 단점
    * 하나하나 확인하는 과정이 포함되어 있어서 UDP보다 느림
* UDP 장점
    * 데이터를 주고받으면서 확인하는 과정이 생략된 만큼 TCP보다 빠름
* UDP 단점
    * 중간에 데이터가 누락되거나 문제가 생기면 해결할 수 있는 방법이 없음

## 07-4 UDP 통신 알아보기

* UDP
    * 기능이 많지 않아 구조가 단순
    * 프로토콜의 크기: 총 8bytes
        1. 출발지 포트: 2bytes
            * UDP를 보내는 쪽의 포트 번호를 작성
        2. 목적지 포트: 2bytes
            * UDP를 받는 쪽의 포트 번호를 작성
        3. 데이터를 캡슐화한 패킷의 전체 길이
        4. 헤더의 체크섬

## 07-5 TCP 통신 알아보기

* TCP
    * 클라이언트와 서버가 통신을 계속 확인하면서 데이터를 주고받으므로 UDP보다 기능이 많음
    * 프로토콜의 크기: 총 20bytes
        1. 출발지 포트: 2bytes
            * TCP를 보내는 쪽의 포트 번호를 작성
        2. 목적지 포트: 2bytes
            * TCP를 받는 쪽의 포트 번호를 작성
        3. 클라이언트와 서버의 통신을 동기화하기 위한 순서 번호, 응답 번호: 각각 4bytes
            * 순서 번호: 데이터의 순서를 식별하는 번호
            * 응답 번호: 수신 측이 데이터를 잘 받았다는 의미로 순서 번호에 1을 더한 값
        4. 헤더의 길이를 의미하는 오프셋과 예약 필드: 1byte
            * 오프셋: TCP 헤더의 크기
                * 헤더의 크기를 4로 나눠서 작성
                * 4bytes의 옵션이 하나씩 추가될 때마다 1씩 증가
            * 예약 필드: 현재 사용하지 않음
        5. TCP 플래그: 1byte
        6. 윈도우와 체크섬, 긴급 포인터: 각각 2bytes
        7. TCP 옵션

### TCP 플래그
플래그 | 명칭 | 의미
---|---|---
URG(urgent) | 긴급 비트 | 긴급 포인터 필드에 값이 채워졌음을 알림
ACK(acknowledgement) | 응답 비트 | 데이터를 수신한 측이 이를 확인했음을 알림
PSH(push) | 밀어넣기 비트 | 데이터를 보내는 패킷이라는 것을 알림
RST(reset) | 초기화 비트 | 강제 연결 초기화
SYN(synchronize) | 동기화 비트 | TCP 연결 설정 초기화를 위한 순서 번호 동기화 시작을 알림
FIN(finish) | 종료 비트 | 송신기가 데이터 보내기를 끝마침

* 연결 수립 과정
    * SYN와 ACK를 사용
* 데이터 송수신 과정
    * PSH와 ACK를 사용
* 연결 종료 과정
    * FIN와 ACK를 사용
* 특수한 경우
    * URG, RST를 사용

### TCP 연결 수립 과정
* 연결 수립 과정
    * TCP를 이용해 통신하는 모든 프로그램이 거치는 과정

* 3방향 핸드셰이크
    1. 클라이언트가 서버에 연결 요청
        * SYN 플래그 설정
        * 임의의 순서 번호와 응답 번호를 0으로 작성하여 서버로 보냄
    2. 서버가 클라이언트의 요청을 수락하면서 자신도 연결을 요청
        * ACK 플래그 + SYN 플래그 설정
        * 임의의 순서 번호와 클라이언트에서 받은 순서 번호에 1을 더한 값을 응답 번호로 TCP를 작성하여 클라이언트로 보냄
    3. 클라이언트가 서버의 요청을 수락
        * 서버가 보낸 응답 번호를 순서 번호에 설정
        * 서버가 보낸 순서 번호에 1을 더한 값을 응답 번호로 TCP를 작성하여 서버로 보냄

### TCP 데이터 송수신 과정
1. 클라이언트가 서버에 데이터를 요청
    * 요청 패킷에 원하는 데이터 정보를 캡슐화하여 서버로 보냄
    * PSH 플래그 + ACK 플래그 설정
    * 순서 번호와 응답 번호는 연결 수립 과정에서 마지막에 서버로 보냈던 번호를 그대로 사용
2. 클라이언트의 요청에 서버가 응답
    * 클라이언트가 요청한 데이터를 응답 패킷으로 캡슐화하여 클라이언트로 보냄
    * PSH 플래그 + ACK 플래그 설정
    * 클라이언트가 보낸 응답 번호와 순서 번호를 각각 순서 번호와 응답 번호로 설정
        * 이때 응답 번호에는 앞 단계에서 서버가 받은 데이터의 크기를 더한 값을 설정하여 보냄
3. 서버의 응답을 클라이언트가 확인
    * 데이터를 잘 받았다는 의미로 다시 패킷을 서버로 보냄
    * ACK 플래그 설정
    * 서버가 보낸 응답 번호와 순서 번호를 각각 순서 번호와 응답 번호로 설정
        * 이때 응답 번호에는 앞 단계에서 클라이언트가 받은 데이터의 크기를 더한 값을 설정하여 보냄

### TCP 연결 종료 과정
1. 클라이언트가 먼저 FIN 플래그가 설정된 TCP를 보냄
    * 이때 마지막 통신에서 클라이언트가 보냈던 시퀸스 번호와 응답 번호를 이어서 사용
2. 해당 패킷을 받은 서버는 이를 수락하는 의미로 ACK 플래그가 설정된 TCP를 응답
3. 서버도 연결을 종료하기 위해 FIN 플래그가 설정된 TCP를 클라이언트에 보냄
4. 클라이언트가 다시 종료를 수락하는 의미로 ACK 플래그가 설정된 TCP를 보냄

## 07-6 TCP의 포트 상태

* TCP를 이용하는 클라이언트 프로그램과 서버 프로그램이 서로의 포트 번호로 연결을 수립하고 데이터를 주고받고 연결을 종료하는 과정을 거치면서 사용하는 포트의 상태는 계속 변경됨

1. 클라이언트가 서버에 연결 요청할 때의 상태
    * 서버 프로그램을 실행하면 포트 번호의 상태를 LISTENING으로 변경
    * 서버가 정상으로 실행 중이라면 클라이언트는 TCP를 이용해 3방향 핸드셰이크 과정을 시작
        * 이때 클라이언트가 첫 번째 패킷에 SYN 플래그를 설정해서 보내면 클라이언트는 SYN_SENT 상태가 됨
2. 서버가 클라이언트의 요청을 수락하면서 자신도 연결을 요청할 때의 상태
    * 클라이언트의 패킷을 받은 서버는 SYN_RECEIVED 상태가 되고 SYN과 ACK 플래그로 패킷을 작성해서 보냄
        * 이때 서버가 사용하는 포트는 다른 클라이언트의 요청도 받을 수 있도록 LISTENING 상태를 유지하면서 현재 패킷을 주고받는 사용자와의 상태만 SYN_RECEIVED로 변경
3. 클라이언트가 서버의 요청을 수락할 때의 상태
    * 서버로부터 요청과 응답을 받은 클라이언트는 마지막으로 응답 프로토콜을 작성해서 보내고, 연결이 수립되었다는 의미로 자신의 포트 상태를 ESTABLISHED로 변경
4. 서버가 클라이언트의 수락을 전달받을 때
    * 해당 패킷을 받은 서버도 포트의 상태를 ESTABLISHED로 변경

# 08 HTTP 통신 요청

## 08-1 HTTP 프로토콜 알아보기

* HTTP
    * 웹 서비스를 이용할 때 사용하는 프로토콜
    * 7계층의 대표적인 프로토콜
    * 클라이언트-서버 모델을 기반으로 동작

### 웹 브라우저가 하는 일
* 웹 브라우저
    * 사용자가 웹 페이지에서 클릭하거나 입력한 내용을 HTTP 프로토콜로 만들어서 웹 서버에 요청하고, 웹 서버가 응답한 웹 페이지 파일을 화면에 출력해 줌
        * ex. 크롬, 엣지, 사파리 등

### 웹 페이지 파일(HTML, CSS, 자바스크립트)
* 웹 페이지 파일
    * 보통 HTML, CSS, 자바스크립트 파일로 이루어져 있음

* HTML
    * 웹 페이지에서 보여 줄 내용을 작성해 둔 문서 파일

* CSS
    * 해당 내용을 예쁘게 보여 주려고 작성해 둔 디자인 설정 파일

* 자바스크립트
    * 웹 페이지에서 다양한 기능을 실행하도록 작성된 스크립트 파일

## 08-2 HTTP 요청 프로토콜의 구조

* 다른 프로토콜들은 16진수로 이루어져 있는데, HTTP는 다른 프로토콜과 달리 문자로 되어 있어서 내용을 쉽게 읽을 수 있음
* 보통 HTTP 프로토콜은 시작 줄, 헤더, 보디 크게 3가지 부분으로 나뉘는데, 요청할 때와 응답할 때 각 부분이 다르게 설정됨

### HTTP 요청 시작 줄
* HTTP 메서드
    * 클라이언트가 웹 서버에 요청하는 방식을 구분하여 미리 알려 주는 기능을 함
    * 메서드마다 특정한 의미가 있고, 웹 서버는 클라이언트의 요청 메서드를 확인해 그에 맞는 응답을 보냄

* URL 주소
    * 웹 서버에 저장된 특정 파일의 위치

* HTTP 버전
    * 요청할 때 사용하는 HTTP의 버전

### HTTP 요청 헤더
* HTTP 요청 헤더
    * 클라이언트와 서버가 데이터를 주고받으면서 필요한 추가 정보를 제공하는 데 사용됨
    * 클라이언트와 서버에 따라서 헤더는 얼마든지 추가될 수 있음

* 일반적으로 사용하는 헤더
    * 호스트
        * 클라이언트가 입력한 URL에서 호스트 주소와 포트 번호를 설정
        * HTTP/1.1 버전에서는 필수로 입력해줘야 한다.
    * 사용자 에이전트
        * 운영체제 버전, 웹 브라우저의 버전 등의 클라이언트 프로그램에 대한 정보를 설정
    * 쿠키
        * 이전에 서버에서 받은 정보가 있다면 쿠키에 포함하여 서버에 전송
    * 콘텐트 형식
        * 요청할 때 보내는 데이터의 형식
    * 콘텐트 길이
        * 요청할 때 보내는 데이터의 크기

### HTTP 요청 보디
* 클라이언트에서 서버로 요청을 보낼 때에 POST 메서드를 이용하면 데이터를 HTTP 프로토콜의 보디에 포함해서 보냄
    * 이때 데이터의 형식에 따라 헤더의 콘텐트 형식이 달라짐

* 대표적인 콘텐트 형식과 데이터를 보내는 방법
    * application/x-www-form-urlencoded
        * 기본적 문자 형태의 데이터를 보낼 때 사용하는 형식
        * 클라이언트가 서버로 보내는 데이터는 키-값 쌍으로 이루어지며 각각의 쌍은 &로 구분
    * multipart/form-data
        * 사진이나 파일 업로드와 같은 데이터를 전송할 때 사용
        * multipart/form-data; 뒤에 지정한 boundary를 이용해서 각 데이터를 파트로 나누고, 파트마다 콘텐트 형식을 다시 작성해서 전송
    * application/json
        * 자바스크립트로 데이터를 전송할 때 일반적으로 사용하는 JSON 형식의 데이터를 전송할 때 사용

# 09 HTTP 통신 응답

## 09-1 웹 서버가 하는 일

* 서버
    * 클라이언트로부터 받은 요청에 응답하는 역할
    * 요청을 처리하고 응답하는 방식에 따라 웹 서버, 웹 애플리케이션 서버, 데이터베이스 서버로 나눌 수 있음
        * 각 서버는 일반적으로 각각 분리된 컴퓨터에서 실행함

* 웹 서버
    * 단순히 서버 컴퓨터에 저장된 HTML, CSS, 자바스크립트 같은 웹 페이지나 이미지, 동영상, 음성 등의 파일을 HTTP 응답 프로토콜에 담아서 클라이언트에 보냄
    * 저장된 파일의 내용을 변경하지 않고 그대로 보내므로 웹 서버가 보내는 데이터를 정적 데이터라고 함
    * ex. 아파치 HTTP 서버, 엔진엑스

* 웹 애플리케이션 서버
    * 서버에 저장된 파일을 그냥 보내는 것이 아니라, 프로그래밍 언어로 작성된 코드를 실행하여 서버 컴퓨터에 저장된 내용이나 데이터베이스 서버에 저장된 내용을 불러와 처리한 후 그 결과를 HTTP 응답 프로토콜에 담아서 클라이언트에 보냄
    * 단순히 파일의 내용을 보내는 것이 아니라, 파일의 내용을 처리한 후 변경할 내용이 있으면 변경해서 보내므로 동적 데이터라고 함

### 웹 서버가 요청 URL을 해석하는 방법
1. 웹 서버가 클라이언트로부터 HTTP 요청 프로토콜을 받으면 그 안에는 특정 웹 페이지를 요청하는 URL이 포함되어 있음
2. 웹 서버는 URL을 확인하고 서버의 설정대로 HTTP 응답 프로토콜을 작성해서 클라이언트에 보냄

```
/* 엔진엑스의 기본 설정 파일 */

... (생략) ...
server {
    listen  80;
    server_name localhost;
    location / {
        root    html;
        index   index.html index.htm;
    }
    error_page  500 502 503 504 /50x.html;
    location = /50x.html {
        root    html;
    }
}
... (생략) ...
```
1. 만약 클라이언트가 요청한 URL이 http://192.168.10.100:80/abc/def 였다면 서버는 location 설정에 따라 abc/def라는 경로를 전달받음
    * location /에서 '/'는 URL에서 포트 다음에 오는 '/'를 의미
    * 만약 location 설정을 'location /abc'로 바꾼다면, 서버는 def로만 전달받음
2. 이렇게 전달받은 경로는 root html; 설정에 따라 지정된 경로에서 파일을 찾음
    * root: 엔진엑스 프로그램이 서버에 저장된 웹 페이지나 각종 파일을 찾을 컴퓨터의 경로
        * ex. root가 C:/test로 되어 있으면, 엔진엑스는 C:/test 폴더 안에서 전달받은 파일을 찾음
            * 또 abc/def를 전달받으면 C:/test 안에서 abc 폴더를 찾고 def라는 이름의 파일을 찾음
3. 찾은 파일을 HTTP 응답 프로토콜로 클라이언트에 보냄

## 09-2 HTTP 응답 프로토콜의 구조

### HTTP 응답 시작 줄
* 버전
* 상태 코드
    * 세 자릿 수
* 상태 문구
    * 상태 코드에 따라 정해진 값

### HTTP 응답 헤더
* 서버
    * 서버에 대한 정보
* 콘텐트 형식
    * 응답할 때 보내는 데이터의 형식
* 콘텐트 길이
    * 응답할 때 보내는 데이터의 크기
* 로케이션
    * 300번 대 상태 코드로 응답할 때 사용되며, 새로운 URL을 알릴 때 사용
* 쿠키 설정
    * 클라이언트의 웹 브라우저에 쿠키를 저장하도록 지시할 때 사용

### HTTP 응답 보디
1. text/html
    * HTML 문서
2. application/json
    * JSON 형식의 데이터
3. image/png
    * PNG 형식의 이미지
4. text/css
    * 웹 페이지를 꾸미는 CSS 스타일 시트

## 09-3 프런트엔드와 백엔드

* 프런트엔드와 백엔드를 나누는 기준
    * 프런트엔드 코드
        * 웹 서버가 실행 중인 컴퓨터에 저장
        * 클라이언트의 요청에 따라 내려받아서 클라이언트 컴퓨터에서 실행
    * 백엔드 코드
        * 웹 애플리케이션 서버가 실행 중인 컴퓨터에 저장
        * 해당 컴퓨터에서 실행

### 프런트엔드와 백엔드를 나누는 이유
1. 역할과 책임을 분리하여 효율적으로 개발과 유지, 보수를 하기 위함
2. 서버의 부하를 분산하기 위함
3. 보안
    * 프런트엔드 코드: 클라이언트 컴퓨터에 내려받아 실행되므로 코드가 노출
    * 백엔드 코드: 서버에서 실행되고 결과만 전달해 주므로 클라이언트가 해당 코드를 보거나 결과를 수정할 수 없음

# 10 공유기 알아보기

## 10-1 공유기가 하는 일

* 공유기의 주요 기능
    * DHCP
        * 공유기에 연결한 컴퓨터에 자동으로 IP 주소를 설정하는 기능
    * NAT
        * 공인 IP 하나를 여러 컴퓨터가 공유해서 사용할 수 있게 해주는 기능

### DHCP - 동적 호스트 구성 프로토콜
* DHCP(dynamic host configuration protocol)
    * 컴퓨터와 공유기를 랜선을 통해 유선으로 연결하거나 와이파이를 통해 무선으로 연결하면 IP 주소를 자동으로 할당해 주는 동적 호스트 구성 프로토콜
    * 공유기에는 UDP 67번 포트를 사용하는 DHCP 서버가 기본으로 설치되어 있는데, 공유기에 연결된 컴퓨터는 DHCP 클라이언트로 공유기와 통신

* DHCP 프로토콜로 공유기와 통신할 때 IP 주소가 아직 없는데 어떻게 통신할 수 있을까?
    * 공유기에 연결된 컴퓨터는 4가지 단계를 거쳐 IP 주소를 할당받음
        * 하지만 현재 컴퓨터에는 기본 게이트웨이 주소도 설정되어 있지 않음
            * IPv4 프로토콜에 출발지 주소는 0.0.0.0처럼 비워 두고, 목적지인 공유기 주소는 255.255.255.255처럼 작성해 브로드캐스트로 통신
    1. Discover(클라이언트에서 브로드캐스트)
        * 컴퓨터가 IP 주소를 할당받고자 패킷을 작성해 같은 네트워크에 연결된 장치에 브로드캐스트로 전송
            * 이때 DHCP 프로토콜에는 각 단계의 통신을 이어갈 수 있도록 랜덤한 값의 트랜잭션 아이디를 설정해서 보냄
            * 해당 패킷을 받은 장치 가운데 목적지 포트 번호를 사용하는 DHCP 서버가 실행 중이지 않은 장치들은 패킷을 무시하고, DHCP 서버가 실행 중인 공유기만 해당 패킷에 응답
    2. Offer(DHCP 서버에서 브로드캐스트)
        * Discover 패킷을 받은 DHCP 서버는 Offer 패킷으로 응답하는데, 아직 Discover 패킷을 보낸 클라이언트와 직접 통신할 수 있는 주소가 없으므로 DHCP 서버도 브로드캐스트로 Offer 패킷을 전송
            * 이때 서버는 Discover 패킷을 통해 받은 트랜잭션 아이디를 그대로 사용하여 Discover 패킷에 대한 응답임을 알려 줌
            * 동시에 DHCP 서버에 설정된 네트워크 대역에 해당하는 IP 주소 가운데 현재 남은 IP 주소 중 하나를 클라이언트에 알려 줌
            * 그리고 클라이언트가 IP 주소와 함께 설정해야 할 서브넷 마스크, 기본 게이트웨이, DNS 서버의 IP 주소, 해당 IP 주소를 사용할 수 있는 임대 기간을 알려 줌
    3. Request(클라이언트에서 브로드캐스트)
        * Discover 패킷을 브로드캐스트로 보냈으므로 같은 네트워크에 DHCP 서버가 여러 개면 클라이언트 컴퓨터는 DHCP별로 Offer 패킷을 여러 개 받음
            * 이때 컴퓨터는 그중 하나를 골라 Request 패킷을 전송함
            * 아직은 컴퓨터에 IP 주소가 설정되지 않았으므로 마찬가지로 브로드캐스트로 보냄
            * 자신이 사용할 IP 주소를 공유기에 최종 요청하는 것
    4. Ack(DHCP 서버 -> 클라이언트)
        * Request 패킷을 받은 DHCP 서버는 마지막으로 해당 IP 주소를 사용해도 된다는 의미로 Ack 패킷을 전송
            * 이 패킷을 전송하고 서버는 해당 IP 주소를 다른 컴퓨터가 할당받지 못하게 사용 중으로 표시
            * 그리고 Ack 패킷을 받은 컴퓨터는 해당 IP 주소와 서브넷 마스크, 기본 게이트웨이, DNS 서버 주소를 자신에게 설정하고 통신을 시작함

### NAT - 네트워크 주소 변환
* NAT(network address translation)
    * 각 컴퓨터는 사설 IP 주소를 사용하고 공유기는 NAT 기능으로 하나의 공인 IP 주소를 공유해서 통신할 수 있게 해줌
        * NAT에는 정적 NAT, 동적 NAT, PAT가 있는데 공유기는 PAT 기술을 사용
    * 장점
        * IP 부족 문제를 해결
        * 보안이 향상
            * 외부에서 내부의 사설 IP 주소를 사용하는 컴퓨터로 직접 접속할 수 없기 때문
            * 실제 네트워크에는 많은 장치가 연결되어 있어도 외부와는 하나의 IP 주소로 통신하므로 하나의 장치로 인식
                * 즉, 외부에서는 내부의 컴퓨터가 몇 대인지, 그리고 어떤 IP 주소를 사용하는지 전혀 알 수 없어서 마치 해당 컴퓨터가 존재하지 않는 것처럼 보임
    * 단점
        * 만약 인터넷으로 여러 사람에게 서비스를 제공해야 하는 서버가 NAT를 이용하는 환경에서 사설 IP를 사용한다면 클라이언트들이 서버를 찾을 수 없게 됨

1. 정적 NAT
    * 내부 네트워크의 각 기기에 다음 표처럼 미리 설정한 공인 IP 주소를 할당하는 방식
        * 내부 기기가 외부 네트워크와 통신할 때마다 항상 같은 공인 IP 주소를 사용하게 됨
        * 내부에서 외부로 요청하는 통신을 하고 외부에서 응답이 오더라도 대응하는 IP 주소를 보고 다시 원래의 내부 기기를 찾아감

2. 동적 NAT
    * 내부 네트워크의 각 기기가 외부 네트워크와 통신할 때 동적으로 공인 IP 주소를 할당하는 방식
        * 각 내부 기기는 필요할 때마다 다음 표처럼 공인 IP 주소 목록에서 사용 가능한 IP를 할당받아 사용하고, 사용을 마치면 해당 IP 주소를 반환
        * 필요할 때 동적으로 공인 IP 주소를 할당받으므로 공인 IP 주소가 변경될 수도 있음

3. PAT(port address translation)
    * 내부 네트워크의 여러 기기가 하나의 공인 IP 주소를 공유하되, 각 내부 기기는 고유한 포트 번호를 할당받아 통신하는 방식
        * 내부에서 외부로 통신할 때 다음 표처럼 내용을 작성하여 외부로 요청을 보내고, 해당 요청에 응답이 돌아오면 다시 삭제
        * 내부 기기들은 하나의 공인 IP를 사용하지만, 내부 기기의 사설 IP 주소와 포트 번호를 조합하여 각각 다른 포트 번호로 동작하므로 서로를 구분할 수 있음

## 10-2 공유기에 연결된 컴퓨터를 인터넷에 공개하기

* 서버가 PAT를 사용하는 공유기와 같은 환경에 연결되어 있다면 클라이언트들이 서버를 찾을 수 없으므로 서버가 클라이언트에 서비스를 제공할 수 없게 됨. 이럴 때 서버는 어떻게 클라이언트에게 서비스를 제공할 수 있을까?
    * 앞 절에서 살펴본 PAT의 표처럼 외부에서 내부로 요청이 올 때 특정 컴퓨터를 찾아갈 수 있도록 미리 내용을 작성해 두면, 외부의 클라이언트들도 서버가 실행 중인 컴퓨터를 찾을 필요 없이 공유기까지만 찾아와서 해당 내용을 확인하고 공유기에 연결된 특정 컴퓨터를 찾아갈 수 있음
        * 즉, 공유기가 사용하는 공인 IP 주소의 특정 포트로 찾아오면 미리 작성해 둔 공유기에 연결된 기기의 특정 포트로 클라이언트의 요청을 보내주는 것
            * 이러한 설정을 포트 포워딩이라고 함

### 포트 포워딩
* 포트 포워딩
    * 외부에서 사설 IP 주소를 사용하는 서버 컴퓨터로 접속할 수 있게 해주는 설정
        * 클라이언트는 사설 IP 주소를 사용하는 서버 컴퓨터로 직접 통신할 수 없으므로 공유기에 포트 포워딩 설정을 통해 사설 IP를 사용하는 컴퓨터로 접속할 수 있게 해주는 것
        * 공유기에 포트 포워딩 설정을 해놓으면 클라이언트는 컴퓨터까지 통신할 필요 없이 공유기에 패킷을 전송
            * 그리고 공유기는 포트 포워딩 설정을 보고 해당 컴퓨터로 패킷을 보냄

# 11 컴퓨터를 쉽게 찾는 방법 - DNS 서버

## 11-1 DNS가 하는 일

* DNS(domain name system)
    * 도메인 이름을 IP 주소로 변환하는 시스템
    * 도메인 이름을 IP 주소로 변환하는 DNS 서버 프로그램과 해당 서비스를 이용하는 DNS 클라이언트 프로그램, 그리고 두 프로그램이 데이터를 주고받는 형식인 DNS 프로토콜로 구성

### 호스트 이름
* 호스트 이름
    * 초창기 컴퓨터 이름은 호스트 이름이라는 255자까지 사용할 수 있는 평면적인 이름 구조를 사용
        * 이름: 컴퓨터에게 별명을 지어주는 것
            * ex. A 컴퓨터는 'test01', B 컴퓨터는 'test02'

* 호스트 파일
    * IP 주소를 사용하는 컴퓨터와 호스트 이름을 사용하는 사람 사이에서 이름과 IP 주소를 매칭할 수단
    * 호스트 이름을 저장해 두는 파일
    * 통신할 호스트 이름을 입력하면 운영체제는 호스트 파일에 적힌 이름을 찾고, 그 이름에 매칭된 IP 주소로 통신하는 것
    * 문제
        1. 255자인 호스트 이름으로 전 세계의 컴퓨터를 구분할 수 없다는 것
        2. 호스트 이름과 이에 매칭된 IP 주소를 호스트 파일로 관리할 때 특정 컴퓨터의 IP 주소나 호스트 이름이 변경되면 호스트 파일을 수정하고 다른 컴퓨터들이 모두 변경된 호스트 파일을 다시 공유해야 한다는 것

### 도메인 이름(FQDN)
* 도메인 이름(fully qualified domain name)
    * 도메인 + 호스트 이름
        * ex. www.naver.com이라는 도메인 이름이 있을 때 'naver.com'은 도메인이고 'www'는 호스트 이름

* 도메인
    * 하나의 영역
    * 한 도메인에는 여러 컴퓨터가 있을 수 있고 각 컴퓨터는 호스트 이름을 가지고 있음
        * ex. naver.com 도메인에는 www라는 호스트 이름의 컴퓨터도 있지만, comic, mail, map과 같은 호스트 이름의 컴퓨터가 있을 수 있음

### DNS 서버 프로그램
* DNS 서버
    * 이름과 IP 주소를 매칭해 둔 호스트 파일을 쉽게 공유하기 위해 만들어짐
    * 전 세계의 많은 컴퓨터의 이름을 한 곳에서 모두 기록하고 관리할 수 없으니, 이를 여러 DNS 서버에 나눠서 관리하고 도메인 이름으로 통신하려는 컴퓨터는 서버로부터 IP 주소를 받아가도록 만든 것

* DNS 서버의 계층 구조
    * 루트 DNS 서버(.)
        * 계층 구조에서 최상위에 위치하며 도메인 주소를 이용해서 IP 주소로 변경할 때 가장 먼저 찾아가는 서버
        * 전 세계에 단 13대만 존재, 루트 DNS 서버의 이름은 a~m까지 있음
            * 각 루트 DNS 서버는 .com, .org, .net, .kr, .jp와 같은 최상위 도메인 DNS 서버의 이름과 IP 주소들을 기록하고 관리
    * 최상위 도메인 DNS 서버(.com.)
        * .com, .org, .net, .kr, .jp와 같은 최상위 도메인 DNS 서버는 권한 있는 DNS 서버의 이름과 IP 주소를 관리
        * 도메인 업체에 일정 비용을 지불하고 등록을 요청하면 권한 있는 DNS 서버의 이름과 IP 주소를 등록해 줌
    * 책임 DNS 서버(.naver.com.)
        * 컴퓨터의 호스트 이름과 IP 주소를 저장
        * 일반적으로 naver.com과 같은 특정 회사의 도메인을 관리하는 DNS 서버 또는 자신이 직접 만든 도메인을 관리하는 DNS 서버를 의미
        * '권한 있는 DNS 서버'라고도 함
    * 권한 없는 DNS 서버(이름 풀이 DNS 서버)
        * 도메인 이름을 입력했을 때 사용자의 컴퓨터를 대신해서 도메인 이름에 해당하는 IP 주소를 알아오는 DNS 서버
        * 루트 DNS 서버, 최상위 도메인 DNS 서버, 권한 있는 DNS 서버 순으로 찾아가면서 IP 주소를 알아 옴
    * 영역 파일
        * 하나의 도메인에 속한 컴퓨터들의 호스트 이름과 IP 주소를 매칭해 둔 파일로 DNS 서버가 관리하는 파일
        * 각각의 정보를 레코드로 구분하여 저장하고 있음
        * 영역 파일에서 각 레코드는 다음과 같은 의미가 있는 설정
            * SOA(start of authority)
                * 영역 파일의 시작 부분에 위치
                * 해당 도메인에 대한 기본 정보를 포함하고 있음
                * 프라이머리 마스터 DNS 서버의 이름, 이메일 주소, 시리얼 번호 등을 정의
                * 영역 파일은 변경될 때마다 시리얼 번호를 높여 갱신
                    * 이로써 DNS 서버들은 영역 파일이 변경되었음을 확인하고 필요할 때만 업데이트 함
            * NS(name server)
                * 해당 도메인에 대한 네임 서버 정보를 지정
                * 주로 해당 도메인을 관리하는 네임 서버들의 호스트 이름을 나열
            * A(address)
                * 호스트 이름과 해당 호스트의 IPv4 주소를 매핑
            * AAAA(IPv6 address)
                * 호스트 이름과 해당 호스트의 IPv6 주소를 매핑
            * CNAME(canonical name)
                * 호스트에 대한 별칭을 정의
                * 한 호스트의 DNS 레코드를 다른 호스트의 레코드로 연결
            * MX(mail exchange)
                * 도메인의 메일 서버 정보를 지정
            * PTR(pointer)
                * 역방향 DNS 조회를 지원하기 위해 사용되며, IP 주소를 호스트 이름으로 매핑
            * TXT(text)
                * 텍스트 정보를 포함하며, 주로 도메인에 대한 추가 정보를 제공

### DNS 클라이언트 프로그램
* 운영체제에는 프로그램이 도메인 이름을 입력하면 DNS 서버에서 IP 주소를 알아 오는 클라이언트 프로그램이 포함되어 있음
    * 따라서 DNS 서비스를 이용하는 클라이언트 프로그램을 굳이 설치하지 않아도 운영체제가 알아서 도메인 이름을 IP 주소로 바꿔 줌

## 11-2 도메인 주소가 IP 주소로 바뀌기까지

* 내 컴퓨터에서 입력한 도메인 이름이 계층 구조로 되어 있는 각 DNS 서버를 통해 IP 주소로 바뀌는 과정
    1. 내 컴퓨터는 www.ddarahakit.com이라는 도메인 이름을 로컬 DNS 서버에게 IP 주소로 바꿔 달라고 요청
        * 이때 로컬 DNS 서버는 IP 주소를 설정할 때 함께 설정한 각 통신사의 DNS 서버 또는 8.8.8.8 같은 구글의 DNS 서버
    2. 로컬 DNS 서버는 루트 DNS 서버에게 'com'이라는 이름의 도메인을 사용하는 컴퓨터의 IP 주소를 물어보고, 루트 DNS 서버는 본인이 관리하는 영역 파일에서 'com'이라는 이름에 매칭된 IP 주소를 알려 줌
        * 참고로 도메인 주소 제일 뒤에는 루트 DNS 서버를 가리키는 '.'이 항상 생략돼 있음
    3. 다시 로컬 DNS 서버는 루트 DNS 서버가 알려 준 IP 주소로 찾아가 'ddarahakit.com'이라는 도메인 이름의 IP 주소를 물어보고, 최상위 DNS 서버는 자신이 관리하는 영역 파일에 ddarahakit.com이라는 이름에 매칭된 IP 주소를 알려 줌
    4. 다시 로컬 DNS 서버는 최상위 DNS 서버가 알려 준 IP 주소로 찾아가 'www.ddarahakit.com'이라는 도메인 이름의 IP 주소를 물어 보고, 책임 DNS 서버는 자신이 관리하는 영역 파일에서 'www'라는 호스트 이름을 사용하는 컴퓨터의 IP 주소를 알려 줌
    5. 마지막으로 www.ddarahakit.com의 IP 주소를 알아낸 로컬 DNS 서버는 자신에게 요청했던 사용자의 컴퓨터에 해당하는 IP 주소를 알려 줌